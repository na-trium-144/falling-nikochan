import { Context, Hono } from "hono";
import { gzip } from "node:zlib";
import { promisify } from "node:util";
import YAML from "yaml";
import * as v from "valibot";
import { MongoClient } from "mongodb";
import { HTTPException } from "hono/http-exception";
import { env } from "hono/adapter";
import { getCookie } from "hono/cookie";
import { ConnInfo } from "hono/conninfo";
import { describeRoute, resolver, validator } from "hono-openapi";
import {
  CidSchema,
  HashSchema,
  rateLimit,
  convertToMin8,
  convertToMin9,
  convertToMin11,
  convertToMin13,
  convertToMin14,
  Chart4,
  Chart5,
  Chart6,
  Chart7,
  Chart8Min,
  Chart9Min,
  Chart11Min,
  Chart13Min,
  Chart14Min,
} from "@falling-nikochan/chart";
import { Bindings, secretSalt } from "../env.js";
import { getChartEntry } from "./chart.js";
import { getIp, updateIp } from "./dbRateLimit.js";
import { errorLiteral } from "../error.js";

interface MinFileAppVars {
  cid: string;
  ip: string;
  type: "yml" | "gz";
  chart: ReturnType<typeof getChartEntry> extends Promise<{ chart: infer C }>
    ? C
    : never;
}

const minFileApp = async (config: {
  getConnInfo: (c: Context) => ConnInfo | null;
}) =>
  new Hono<{
    Bindings: Bindings;
    Variables: MinFileAppVars;
  }>({ strict: false })
    .on(
      ["GET"],
      "/:cid",
      validator("param", v.object({ cid: CidSchema() })),
      validator(
        "query",
        v.object({
          p: v.optional(
            v.pipe(v.string(), v.minLength(1), v.description("plain password"))
          ),
          ph: v.optional(
            v.pipe(
              HashSchema(),
              v.description(
                "Hashed password generated by /api/hashPasswd. pUserSalt cookie must be set."
              )
            )
          ),
          pbypass: v.optional(v.string()),
          type: v.optional(
            v.pipe(
              v.picklist(["yml", "gz"]),
              v.description("Output format: yml (default) or gz (gzip compressed YAML)")
            )
          ),
        })
      ),
      validator(
        "cookie",
        v.object({
          pUserSalt: v.optional(v.string()),
        })
      ),
      async (c, next) => {
        const { cid } = c.req.valid("param");
        const { p, ph, pbypass, type } = c.req.valid("query");
        const ip = getIp(c, config.getConnInfo);
        const v9UserSalt =
          env(c).API_ENV === "development"
            ? getCookie(c, "pUserSalt")
            : getCookie(c, "pUserSalt", "host");
        const bypass = !!pbypass && env(c).API_ENV === "development";
        const pSecretSalt = secretSalt(env(c));
        const client = new MongoClient(env(c).MONGODB_URI);
        try {
          await client.connect();
          const db = client.db("nikochan");
          if (!(await updateIp(env(c), db, ip, "chartFile"))) {
            return c.json(
              {
                message: "tooManyRequest",
              },
              429,
              { "retry-after": rateLimit.chartFile.toString() }
            );
          }

          let { chart } = await getChartEntry(db, cid, {
            bypass,
            rawPasswd: p,
            v9PasswdHash: ph,
            v9UserSalt,
            pSecretSalt,
          });
          
          c.set("cid", cid);
          c.set("ip", ip);
          c.set("type", type || "yml");
          c.set("chart", chart);
          await next();
        } finally {
          await client.close();
        }
      }
    )
    .get(
      "/:cid",
      describeRoute({
        description:
          "Get a chart file in YAML format (optionally gzip compressed). " +
          "For chart versions 8-14, the data is converted to Min format (Chart8Min-Chart14Min). " +
          "For chart versions 4-7, the data is kept as-is (Chart4-Chart7). " +
          "Requires a password (either p or ph).",
        responses: {
          200: {
            description: "Successful response",
            content: {
              "text/yaml": {
                schema: resolver(v.object({ message: v.string() })),
              },
              "application/gzip": {
                schema: resolver(v.object({ message: v.string() })),
              },
            },
          },
          400: {
            description: "invalid chart id or password not specified",
            content: {
              "application/json": {
                schema: resolver(v.object({ message: v.string() })),
              },
            },
          },
          401: {
            description: "wrong password",
            content: {
              "application/json": {
                schema: resolver(await errorLiteral("badPassword")),
              },
            },
          },
          404: {
            description: "chart id not found",
            content: {
              "application/json": {
                schema: resolver(await errorLiteral("chartIdNotFound")),
              },
            },
          },
          429: {
            description: "Rate limited",
            content: {
              "application/json": {
                schema: resolver(await errorLiteral("tooManyRequest")),
              },
            },
          },
        },
      }),
      async (c) => {
        const chart = c.get("chart");
        const type = c.get("type");

        let chartMin:
          | Chart4
          | Chart5
          | Chart6
          | Chart7
          | Chart8Min
          | Chart9Min
          | Chart11Min
          | Chart13Min
          | Chart14Min;

        // Convert to Min format for ver8-14, keep as-is for ver4-7
        switch (chart.ver) {
          case 4:
            chartMin = chart;
            break;
          case 5:
            chartMin = chart;
            break;
          case 6:
            chartMin = chart;
            break;
          case 7:
            chartMin = chart;
            break;
          case 8:
            chartMin = convertToMin8(chart);
            break;
          case 9:
          case 10:
            chartMin = convertToMin9(chart);
            break;
          case 11:
          case 12:
            chartMin = convertToMin11(chart);
            break;
          case 13:
            chartMin = convertToMin13(chart);
            break;
          case 14:
            chartMin = convertToMin14(chart);
            break;
          default:
            chart satisfies never;
            throw new HTTPException(500, {
              message: "unsupportedChartVersion",
            });
        }

        // Convert to YAML
        // indentSeq: false makes YAML more compact by not indenting sequences,
        // matching the format used in the frontend editor
        const yml = YAML.stringify(chartMin, { indentSeq: false });

        if (type === "gz") {
          // Return gzip compressed YAML
          const compressed = await promisify(gzip)(Buffer.from(yml, "utf-8"));
          return c.body(compressed, 200, {
            "Content-Type": "application/gzip",
            "Cache-Control": "no-transform",
          });
        } else {
          // Return plain YAML
          return c.body(yml, 200, {
            "Content-Type": "text/yaml; charset=utf-8",
          });
        }
      }
    );

export default minFileApp;
