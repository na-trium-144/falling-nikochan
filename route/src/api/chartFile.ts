import { Hono } from "hono";
import msgpack from "@ygoe/msgpack";
import {
  ChartEdit,
  currentChartVer,
  hashLevel,
  numEvents,
  validateChart,
  chartMaxEvent,
  fileMaxSize,
  CidSchema,
  HashSchema,
  ChartEditSchema13,
} from "@falling-nikochan/chart";
import { Db, MongoClient } from "mongodb";
import {
  ChartEntry,
  ChartEntryCompressed,
  chartToEntry,
  entryToChart,
  getChartEntry,
  zipEntry,
} from "./chart.js";
import { Bindings, secretSalt } from "../env.js";
import { env } from "hono/adapter";
import { getCookie } from "hono/cookie";
import { HTTPException } from "hono/http-exception";
import * as v from "valibot";
import { getYTDataEntry } from "./ytData.js";
import { describeRoute, resolver, validator } from "hono-openapi";
import { errorLiteral } from "../error.js";
import { join, dirname } from "node:path";
import dotenv from "dotenv";
dotenv.config({ path: join(dirname(process.cwd()), ".env") });

/**
 * Chart9Editデータで送受信するchangePasswd, /api/chartFileのpパラメータは生のパスワード
 * データベースに保存するpServerHash = hash(cid + passwd + process.env.SECRET_SALT + pRandomSalt)
 *   pRandomSaltはcidごとにランダムに1回生成し固定
 * chartFileのクエリパラメータph,localStorageに保存するph = hash(pServerHash + pUserSalt)
 *   pUserSaltは /api/hashPasswd でランダムにセットされる
 *
 * /api/chartFile には p=passwd または ph=hash(pServerHash + pUserSalt) を指定してアクセスする
 * POST時のデータのchangePasswdをnullにすると以前のパスワードを次回も使用し、nullでない場合それを新しいパスワードとしてデータベースを更新
 *
 * v8以前で空文字列パスワードで保存していたデータについては、 pServerhash=pRandomSalt=null
 * v9以降では空文字列パスワードでの上書き保存は許されない
 *
 * また、development環境に限り /api/chartFile/cid?pbypass=1 でスキップできる
 */
interface ChartFileAppVars {
  cid: string;
  ip: string;
  entry: ChartEntry;
  chart: ReturnType<typeof entryToChart>;
  db: Db;
  pSecretSalt: string;
}
const chartFileApp = new Hono<{
  Bindings: Bindings;
  Variables: ChartFileAppVars;
}>({ strict: false })
  .on(
    ["GET", "POST", "DELETE"],
    "/:cid",
    validator("param", v.object({ cid: CidSchema() })),
    validator(
      "query",
      v.object({
        p: v.optional(
          v.pipe(v.string(), v.minLength(1), v.description("plain password"))
        ),
        ph: v.optional(
          v.pipe(
            HashSchema(),
            v.description(
              "Hashed password generated by /api/hashPasswd. pUserSalt cookie must be set."
            )
          )
        ),
        pbypass: v.optional(v.string()),
      })
    ),
    validator(
      "cookie",
      v.object({
        pUserSalt: v.optional(v.string()),
      })
    ),
    async (c, next) => {
      const { cid } = c.req.valid("param");
      const { p, ph, pbypass } = c.req.valid("query");
      const ip = String(
        c.req.header("x-forwarded-for")?.split(",").at(-1)?.trim()
      ); // nullもundefinedも文字列にしちゃう
      const v9UserSalt =
        env(c).API_ENV === "development"
          ? getCookie(c, "pUserSalt")
          : getCookie(c, "pUserSalt", "host");
      const bypass = !!pbypass && env(c).API_ENV === "development";
      const pSecretSalt = secretSalt(env(c));
      const client = new MongoClient(env(c).MONGODB_URI);
      try {
        await client.connect();
        const db = client.db("nikochan");
        let { entry, chart } = await getChartEntry(db, cid, {
          bypass,
          rawPasswd: p,
          v9PasswdHash: ph,
          v9UserSalt,
          pSecretSalt,
        });
        // 必要なデータをコンテキストに保存
        c.set("cid", cid);
        c.set("ip", ip);
        c.set("entry", entry);
        c.set("chart", chart);
        c.set("db", db);
        c.set("pSecretSalt", pSecretSalt);
        await next();
      } finally {
        await client.close();
      }
    }
  )
  .get(
    "/:cid",
    describeRoute({
      description:
        "Get a raw chart file in MessagePack format. Requires a password (either p or ph). " +
        "Note that the chart data format can be either Chart4, Chart5, Chart6, Chart7, Chart8Edit, Chart9Edit, Chart11Edit or Chart13Edit, " +
        `while this documentation only describes Chart${currentChartVer}Edit format. ` +
        `The file format used by the chart editor is a subset of Chart${currentChartVer}Edit, ` +
        `so it is possible to import API data into the chart editor, but not the other way around.`,
      responses: {
        200: {
          description: "Successful response",
          content: {
            "application/vnd.msgpack": {
              schema: resolver(ChartEditSchema13()),
            },
          },
        },
        400: {
          description: "invalid chart id or password not specified",
          content: {
            "application/json": {
              schema: resolver(v.object({ message: v.string() })),
            },
          },
        },
        401: {
          description: "wrong password",
          content: {
            "application/json": {
              schema: resolver(await errorLiteral("badPassword")),
            },
          },
        },
        404: {
          description: "chart id not found",
          content: {
            "application/json": {
              schema: resolver(await errorLiteral("chartIdNotFound")),
            },
          },
        },
      },
    }),
    (c) => {
      const chart = c.get("chart");
      return c.body(new Blob([msgpack.serialize(chart)]).stream(), 200, {
        "Content-Type": "application/vnd.msgpack",
      });
    }
  )
  .delete(
    "/:cid",
    describeRoute({
      description:
        "Soft delete a chart. The chart will be marked as deleted and won't appear in searches or latest/popular lists. Requires a password (either p or ph).",
      responses: {
        204: {
          description: "No content, chart deleted successfully",
        },
        400: {
          description: "invalid chart id or password not specified",
          content: {
            "application/json": {
              schema: resolver(v.object({ message: v.string() })),
            },
          },
        },
        401: {
          description: "wrong password",
          content: {
            "application/json": {
              schema: resolver(await errorLiteral("badPassword")),
            },
          },
        },
        404: {
          description: "chart id not found",
          content: {
            "application/json": {
              schema: resolver(await errorLiteral("chartIdNotFound")),
            },
          },
        },
      },
    }),
    async (c) => {
      const cid = c.get("cid");
      const db = c.get("db");
      await db.collection<ChartEntryCompressed>("chart").updateOne(
        { cid },
        {
          $set: {
            // levelsCompressed: null,
            deleted: true,
          },
        }
      );
      return c.body(null, 204);
    }
  )
  .post(
    "/:cid",
    describeRoute({
      description:
        "Update a chart file with new data in MessagePack format. " +
        `The chart data format must be the latest format, Chart${currentChartVer}Edit. ` +
        "The previous password is required (either p or ph). If the posted chart data has a different password, it will be used next time.",
      requestBody: {
        description: "Chart data in MessagePack format. See also GET response.",
        required: true,
        content: {
          "application/vnd.msgpack": {
            // ↓scalarのUIに現れない...
            schema: ChartEditSchema13(),
          },
        },
      },
      responses: {
        204: {
          description: "No content, chart updated successfully",
        },
        400: {
          description: "invalid chart id or password not specified",
          content: {
            "application/json": {
              schema: resolver(v.object({ message: v.string() })),
            },
          },
        },
        401: {
          description: "wrong password",
          content: {
            "application/json": {
              schema: resolver(await errorLiteral("badPassword")),
            },
          },
        },
        404: {
          description: "chart id not found",
          content: {
            "application/json": {
              schema: resolver(await errorLiteral("chartIdNotFound")),
            },
          },
        },
        409: {
          description: `chart version is older than ${currentChartVer}`,
          content: {
            "application/json": {
              schema: resolver(await errorLiteral("oldChartVersion")),
            },
          },
        },
        413: {
          description: "Chart file too large",
          content: {
            "application/json": {
              schema: resolver(
                await errorLiteral("tooLargeFile", "tooManyEvent")
              ),
            },
          },
        },
        415: {
          description: "Invalid chart format",
          content: {
            "application/json": {
              schema: resolver(v.object({ message: v.string() })),
            },
          },
        },
      },
    }),
    async (c) => {
      const cid = c.get("cid");
      const ip = c.get("ip");
      const entry = c.get("entry");
      const db = c.get("db");
      const pSecretSalt = c.get("pSecretSalt");

      const chartBuf = await c.req.arrayBuffer();
      if (chartBuf.byteLength > fileMaxSize) {
        throw new HTTPException(413, {
          message: "tooLargeFile",
          // message: `Chart too large (file size is ${chartBuf.byteLength} / ${fileMaxSize})`,
        });
      }

      const newChartObj = msgpack.deserialize(chartBuf);
      if (
        typeof newChartObj.ver === "number" &&
        newChartObj.ver < currentChartVer
      ) {
        throw new HTTPException(409, { message: "oldChartVersion" });
      }

      let newChart: ChartEdit;
      try {
        newChart = await validateChart(newChartObj);
      } catch (e) {
        console.error(e);
        throw new HTTPException(415, { message: (e as Error).toString() });
      }

      if (numEvents(newChart) > chartMaxEvent) {
        throw new HTTPException(413, {
          message: "tooManyEvent",
          // message: `Chart too large (number of events is ${numEvents(
          //   newChart
          // )} / ${chartMaxEvent})`,
        });
      }

      // update Time
      const prevHashes = entry.levelBrief
        .filter((l) => !l.unlisted)
        .map((l) => l.hash);
      const newHashes = await Promise.all(
        newChart.levels
          .filter((l) => !l.unlisted)
          .map((level) => hashLevel(level))
      );
      let updatedAt = entry.updatedAt;
      if (
        prevHashes.length !== newHashes.length ||
        !newHashes.every((h, i) => h === prevHashes.at(i)) ||
        (!entry.published && newChart.published)
      ) {
        updatedAt = new Date().getTime();
      }

      await db.collection<ChartEntryCompressed>("chart").updateOne(
        { cid },
        {
          $set: await zipEntry(
            await chartToEntry(
              newChart,
              cid,
              updatedAt,
              ip,
              await getYTDataEntry(env(c), db, newChart.ytId),
              pSecretSalt,
              entry
            )
          ),
        }
      );
      return c.body(null, 204);
    }
  );

export default chartFileApp;
